<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Performance Test</title>
    <style>
        body { font-family: Arial, sans-serif; background: #f0f0f0; text-align: center; margin: 0; padding: 20px; }
        .container { max-width: 600px; margin: 0 auto; background: white; padding: 20px; border-radius: 10px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        button { padding: 12px 20px; margin: 10px; font-size: 16px; cursor: pointer; border: none; border-radius: 5px; background: #007bff; color: white; }
        button:hover { background: #0056b3; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        #results { margin-top: 30px; font-size: 24px; }
        .gauge { width: 200px; height: 200px; margin: 20px auto; }
        .log { margin-top: 20px; white-space: pre-line; text-align: left; background: #f8f8f8; padding: 10px; border-radius: 5px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Network Performance Test</h1>
        <p>Based on OpenSpeedTestâ„¢ + DNS Measurement</p>
        
        <button id="dnsBtn" onclick="measureDNS()">Test DNS Lookup</button>
        <button id="startBtn" onclick="startTest()">Start Full Speed Test</button>
        
        <div id="results"></div>
        <div class="gauge"><svg id="gauge" viewBox="0 0 100 100"></svg></div>
        <div class="log" id="log"></div>
    </div>

    <script>
        // Configuration (same as OpenSpeedTest style)
        const servers = [{ ServerName: "Local Server", Download: "downloading/garbage.php?ckSize=100", Upload: "upload/", ping: "" }];
        let currentTest = null;
        let results = { dns: '-', ping: '-', jitter: '-', download: '-', upload: '-' };

        function log(msg) {
            document.getElementById('log').innerHTML += msg + '<br>';
        }

        function updateResults() {
            document.getElementById('results').innerHTML = `
                DNS Lookup: ${results.dns}<br>
                Ping: ${results.ping}<br>
                Jitter: ${results.jitter}<br>
                Download: ${results.download}<br>
                Upload: ${results.upload}
            `;
        }

        // === New: DNS Lookup Measurement ===
        async function measureDNS() {
            const btn = document.getElementById('dnsBtn');
            btn.disabled = true;
            log('Measuring DNS lookup time...');
            
            // Use a unique subdomain or random query on a known domain to force DNS (avoid cache)
            const domain = 'dns.google';
            const url = `https://${Math.random().toString(36).substring(7)}.${domain}/favicon.ico?t=${Date.now()}`;
            
            const img = new Image();
            const start = performance.now();
            
            img.onload = img.onerror = () => {
                const entries = performance.getEntriesByName(url);
                if (entries.length > 0) {
                    const timing = entries[0];
                    const dnsTime = timing.domainLookupEnd - timing.domainLookupStart;
                    results.dns = dnsTime > 0 ? `${dnsTime.toFixed(1)} ms` : 'Cached (0 ms)';
                    log(`DNS Lookup Time: ${results.dns}`);
                } else {
                    results.dns = 'Failed';
                    log('DNS measurement failed');
                }
                updateResults();
                btn.disabled = false;
            };
            
            img.src = url;
        }

        // === Core Speed Test (simplified from OpenSpeedTest logic) ===
        function startTest() {
            document.getElementById('startBtn').disabled = true;
            log('Starting full test...');
            results = { dns: results.dns, ping: '-', jitter: '-', download: '-', upload: '-' };
            updateResults();

            testPing(() => {
                testDownload(() => {
                    testUpload(() => {
                        log('Test completed!');
                        document.getElementById('startBtn').disabled = false;
                    });
                });
            });
        }

        function testPing(callback) {
            log('Testing Ping & Jitter...');
            let pings = [];
            let count = 20; // samples

            function pingOnce() {
                const start = performance.now();
                const xhr = new XMLHttpRequest();
                xhr.open('HEAD', 'downloading/?' + Date.now(), true);
                xhr.timeout = 5000;
                xhr.onload = xhr.onerror = xhr.ontimeout = () => {
                    if (xhr.status >= 200 && xhr.status < 400) {
                        pings.push(performance.now() - start);
                    }
                    if (--count > 0) pingOnce();
                    else {
                        pings.sort((a,b)=>a-b);
                        const avg = pings.reduce((a,b)=>a+b)/pings.length;
                        const jitter = pings.reduce((a,b,i,arr)=>a + Math.abs(b - arr[i-1]),0)/(pings.length-1);
                        results.ping = avg.toFixed(1) + ' ms';
                        results.jitter = jitter.toFixed(1) + ' ms';
                        log(`Ping: ${results.ping} | Jitter: ${results.jitter}`);
                        updateResults();
                        callback();
                    }
                };
                xhr.send();
            }
            pingOnce();
        }

        function testDownload(callback) {
            log('Testing Download...');
            let totalBytes = 0;
            let startTime = performance.now();
            let threads = 6;
            let active = threads;

            function thread() {
                const xhr = new XMLHttpRequest();
                xhr.responseType = 'blob';
                xhr.open('GET', `downloading/garbage.php?ckSize=50&${Date.now()}`, true); // Adjust size as needed
                xhr.onprogress = e => {
                    if (e.lengthComputable) totalBytes += e.loaded;
                };
                xhr.onload = () => {
                    if (--active === 0) finish();
                };
                xhr.onerror = () => { if (--active === 0) finish(); };
                xhr.send();
            }

            for (let i = 0; i < threads; i++) thread();

            const interval = setInterval(() => {
                const elapsed = (performance.now() - startTime) / 1000;
                const speed = (totalBytes * 8 / elapsed / 1000000).toFixed(1);
                results.download = speed + ' Mbps';
                updateResults();
            }, 500);

            function finish() {
                clearInterval(interval);
                const elapsed = (performance.now() - startTime) / 1000;
                const speed = (totalBytes * 8 / elapsed / 1000000).toFixed(1);
                results.download = speed + ' Mbps';
                log(`Download: ${results.download}`);
                updateResults();
                callback();
            }
        }

        function testUpload(callback) {
            log('Testing Upload...');
            const dataSize = 10 * 1024 * 1024; // 10MB
            const blob = new Blob([new Uint8Array(dataSize)]);
            let totalSent = 0;
            let startTime = performance.now();
            let threads = 4;
            let active = threads;

            function thread() {
                const xhr = new XMLHttpRequest();
                xhr.open('POST', 'upload/', true);
                xhr.upload.onprogress = e => {
                    if (e.lengthComputable) totalSent += e.loaded;
                };
                xhr.onload = xhr.onerror = () => {
                    if (--active === 0) finish();
                };
                xhr.send(blob);
            }

            for (let i = 0; i < threads; i++) thread();

            const interval = setInterval(() => {
                const elapsed = (performance.now() - startTime) / 1000;
                if (elapsed > 0) {
                    const speed = (totalSent * 8 / elapsed / 1000000).toFixed(1);
                    results.upload = speed + ' Mbps';
                    updateResults();
                }
            }, 500);

            function finish() {
                clearInterval(interval);
                const elapsed = (performance.now() - startTime) / 1000;
                const speed = (totalSent * 8 / elapsed / 1000000).toFixed(1);
                results.upload = speed + ' Mbps';
                log(`Upload: ${results.upload}`);
                updateResults();
                callback();
            }
        }
    </script>
</body>
</html>
